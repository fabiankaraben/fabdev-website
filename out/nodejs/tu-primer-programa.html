<!DOCTYPE html><html lang="es"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="¡Hola! Soy Fabián, desarrollador de software en Go y Flutter. Este blog es para compartir lo que aprendo cada día.."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Cómo escribir y ejecutar tu primer programa en Node.js | FabDev</title><meta property="og:image" content="/assets/nodejs/tu-primer-programa.png"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/4b09f911218f4103.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4b09f911218f4103.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e1f6961df2961232.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e1f6961df2961232.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-e47bb435dabe4202.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c99dbd9fb9deefcc.js" defer=""></script><script src="/_next/static/chunks/202-747faafb2b860ef1.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...slug%5D-9b607dc726564936.js" defer=""></script><script src="/_next/static/Wx3sdiSJXS0VkloYAT539/_buildManifest.js" defer=""></script><script src="/_next/static/Wx3sdiSJXS0VkloYAT539/_ssgManifest.js" defer=""></script><script src="/_next/static/Wx3sdiSJXS0VkloYAT539/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><div class="border-b bg-neutral-50 border-neutral-200"><div class="container mx-auto px-5"><div class="py-2 text-center text-sm">El código fuente de este blog está<!-- --> <a href="https://github.com/fabiankaraben/fabdev-website" class="underline hover:text-blue-600 duration-200 transition-colors">disponible en GitHub</a>.</div></div></div><main><div class="container mx-auto px-5"><h2 class="text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a href="/">FabDev</a></h2><article class="mb-32"><div class="max-w-5xl mx-auto "><h1 class="text-5xl md:text-7xl lg:text-6xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">Cómo escribir y ejecutar tu primer programa en Node.js</h1><div class="hidden md:block md:mb-12"><div class="flex items-center"><img src="/assets/authors/fabian.png" class="w-12 h-12 rounded-full mr-4" alt="Fabián Karaben"/><div class="text-xl font-bold">Fabián Karaben</div></div></div><div class="mb-8 md:mb-16 sm:mx-0"><div class="sm:mx-0"><img src="/assets/nodejs/tu-primer-programa.png" alt="Cover Image for Cómo escribir y ejecutar tu primer programa en Node.js" class="shadow-sm"/></div></div><div class="max-w-4xl mx-auto"><div class="block md:hidden mb-6"><div class="flex items-center"><img src="/assets/authors/fabian.png" class="w-12 h-12 rounded-full mr-4" alt="Fabián Karaben"/><div class="text-xl font-bold">Fabián Karaben</div></div></div><div class="mb-6 text-lg"><time dateTime="2021-12-15T05:35:07.322Z">December	15, 2021</time></div></div></div><div class="max-w-4xl mx-auto prose prose-xl"><div class="markdown-styles_markdown__h_8de"><p>Node.js es un entorno de ejecución de código abierto popular que puede ejecutar JavaScript fuera del navegador mediante el motor JavaScript V8, que es el mismo motor que se utiliza el navegador web Google Chrome para la ejecución de JavaScript. El <em>runtime</em> de Node se usa comúnmente para crear herramientas de línea de comandos y servidores web.</p>
<p>Aprender <strong>Node.js</strong> te permitirá escribir tu código de frontend y tu código de backend en el mismo lenguaje. El uso de JavaScript en toda tu pila de trabajo puede ayudarte a reducir el tiempo de desarrollo, además las bibliotecas se compartirán fácilmente entre el servidor backend y tus proyectos frontend.</p>
<p>Además, gracias a su soporte para ejecución asincrónica, Node.js sobresale en tareas intensivas de I/O (Entrada/Salida), que es lo que lo hace tan adecuado para la web. Las aplicaciones en tiempo real, como la transmisión de video, o las aplicaciones que envían y reciben datos continuamente, pueden ejecutarse de manera más eficiente cuando se escriben en Node.js.</p>
<p>En este tutorial, crearás tu primer programa con el runtime de Node.js. Se te presentarán algunos conceptos específicos de Node y te abrirás camino para crear un programa que ayude a los usuarios a inspeccionar las variables de entorno en su sistema. Para hacer esto, aprenderás cómo enviar cadenas a la consola, recibir información del usuario y acceder a las variables de entorno.</p>
<h2>Prerrequisitos</h2>
<p>Para completar este tutorial, necesitarás:</p>
<ul>
<li>
<p>Node.js instalado en tu máquina de desarrollo. Este tutorial usa Node.js versión 10.16.0. Para instalar esto en macOS o Ubuntu 18.04, sigue los pasos en <a href="https://www.digitalocean.com/community/tutorials/how-to-install-node-js-and-create-a-local-development-environment-on-macos">Cómo instalar Node.js y crear un entorno de desarrollo local en macOS</a> o la sección "Instalación mediante un PPA" de <a href="https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-18-04">Cómo instalar Node.js en Ubuntu 18.04</a>.</p>
</li>
<li>
<p>Un conocimiento básico de JavaScript, que puedes encontrar aquí: <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-javascript">Cómo codificar en JavaScript</a>.</p>
</li>
</ul>
<h2>Paso 1 - Salidas en la consola</h2>
<p>Para escribir un programa "¡Hola, mundo!", abre un editor de texto de línea de comando como <em>nano</em> y crea un nuevo archivo:</p>
<pre><code class="language-bash">nano hello.js
</code></pre>
<p>Con el editor de texto abierto, escribe el siguiente código:</p>
<pre><code class="language-javascript">console.log("Hello World");
</code></pre>
<p>El objeto de <code>console</code> en Node.js es proporcionar métodos simples para escribir en <code>stdout</code>, <code>stderr</code> o en cualquier otro flujo de Node.js, que en la mayoría de los casos es la línea de comandos. El método <code>log</code> imprime el contenido especificado en la salida estándar, para que puedas verlo en tu consola.</p>
<p>En el contexto de Node.js, los <code>streams</code> son objetos que pueden recibir datos, como la transmisión <code>stdout</code>, u objetos que pueden generar datos, como un conector de red o un archivo. En el caso de las transmisiones (<code>streams</code>) <code>stdout</code> y <code>stderr</code>, todos los datos que se les envíen se mostrarán en la consola. Una de las mejores cosas de las transmisiones es que se redirigen fácilmente, en cuyo caso puedes redirigir la salida de tu programa a un archivo, por ejemplo.</p>
<p>Guarda los cambios y cierra nano presionando <em>CTRL+X</em>, y cuando se te solicite guardar el archivo, presiona <em>Y</em>. Ahora tu programa está listo para ejecutarse.</p>
<h2>Paso 2 - Ejecución del programa</h2>
<p>Para ejecutar este programa, utiliza el comando de <code>node</code> de la siguiente manera:</p>
<pre><code class="language-bash">node hello.js
</code></pre>
<p>El programa <code>hello.js</code> se ejecutará y mostrará el siguiente resultado:</p>
<pre><code class="language-bash">Hello World
</code></pre>
<p>El intérprete de Node.js leyó el archivo y ejecutó <code>console.log("Hello World");</code> llamando al método <code>log</code> del objeto global <code>console</code>. La cadena <code>"Hello World"</code> se pasó como argumento a la función <code>log</code>.</p>
<p>Aunque las comillas son necesarias en el código para indicar que el texto es una cadena, no se imprimen en la pantalla.</p>
<p>Una vez confirmado que el programa funciona, hagámoslo más interactivo.</p>
<h2>Paso 3 - Recibir de la entrada del usuario a través de argumentos de línea de comandos</h2>
<p>Cada vez que ejecutas  programa Node.js "¡Hola, mundo!", produces la misma salida. Para que el programa sea más dinámico, obtengamos información del usuario y mostrémosla en la pantalla.</p>
<p>Las herramientas de línea de comandos a menudo aceptan varios argumentos que modifican su comportamiento. Por ejemplo, ejecutar <code>node</code> con el argumento <code>--version</code> imprime la versión instalada en lugar de ejecutar el intérprete. En este paso, harás que tu código acepte la entrada del usuario a través de argumentos de línea de comandos.</p>
<p>Para ello, crea un nuevo archivo <code>arguments.js</code> con nano:</p>
<pre><code class="language-bash">nano arguments.js
</code></pre>
<p>Escribe el siguiente código:</p>
<pre><code class="language-javascript">console.log(process.argv);
</code></pre>
<p>El objeto <code>process</code> es un objeto Node.js global que contiene funciones y datos relacionados con el proceso Node.js que se está ejecutando actualmente. La propiedad <code>argv</code> es una array de strings que contiene todos los argumentos pasados al programa desde la línea de comandos.</p>
<p>Guarda los cambios y sal de nano escribiendo <em>CTRL+X</em>, cuando se te solicite guardar el archivo, presiona <em>Y</em>.</p>
<p>Ahora, cuando ejecutes este programa, añade algunos argumentos al comando, como por ejemplo:</p>
<pre><code class="language-bash">node arguments.js hello world
</code></pre>
<p>La salida se parecerá a la siguiente:</p>
<pre><code class="language-bash">[ '/usr/bin/node',
  '/home/sammy/first-program/arguments.js',
  'hello',
  'world' ]
</code></pre>
<p>El primer argumento en el array <code>process.argv</code> es siempre la ubicación del binario Node.js que está ejecutando el programa. El segundo argumento es siempre la ubicación del archivo que se está ejecutando. Los argumentos restantes son los que ingresó el usuario, en este caso: <code>hello</code> y <code>world</code>.</p>
<p>Lo que más nos interesa son los argumentos que ingresó el usuario, no los predeterminados que proporciona Node.js. Abre el archivo <code>arguments.js</code> nuevamente para editarlo:</p>
<pre><code class="language-bash">nano arguments.js
</code></pre>
<p>Cambiar <code>console.log(process.argv);</code> a lo siguiente:</p>
<pre><code class="language-javascript">console.log(process.argv.slice(2));
</code></pre>
<p>Debido a que <code>argv</code> es un array, puedes usar el método <code>slice</code> integrado de JavaScript que devuelve una selección de elementos. Cuando proporcionas a la función <code>slice</code> el valor <code>2</code> como argumento, obtienes todos los elementos de <code>argv</code> que vienen después de su segundo elemento; es decir, los argumentos que ingresó el usuario.</p>
<p>Vuelve a ejecutar el programa con el comando <code>node</code> y los mismos argumentos que la última vez:</p>
<pre><code class="language-bash">node arguments.js hello world
</code></pre>
<p>Ahora, la salida se ve así:</p>
<pre><code class="language-bash">[ 'hello', 'world' ]
</code></pre>
<p>Ahora que ya puedes recopilar información del usuario, recopilemos también información del entorno del programa.</p>
<h2>Paso 4 - Acceder a las variables de entorno</h2>
<p>Las variables de entorno son datos de tipo <em>clave:valor</em> almacenados fuera de un programa y proporcionados por el sistema operativo. Por lo general, los establece el sistema o el usuario y están disponibles para todos los procesos en ejecución con fines de configuración o de estado. Puedes utilizar el objeto <code>process</code> de Node para acceder a ellos.</p>
<p>Utiliza nano para crear un nuevo archivo <code>environment.js</code>:</p>
<pre><code class="language-bash">nano environment.js
</code></pre>
<p>Agrega el siguiente código:</p>
<pre><code class="language-javascript">console.log(process.env);
</code></pre>
<p>El objeto <code>env</code> almacena todas las variables de entorno que están disponibles cuando Node.js está ejecutando el programa.</p>
<p>Guarda y sal como antes, y ejecuta el archivo <code>environment.js</code> con el comando <code>node</code>.</p>
<pre><code class="language-bash">node environment.js
</code></pre>
<p>Al ejecutar el programa, deberías ver un resultado similar al siguiente:</p>
<pre><code class="language-bash">{ SHELL: '/bin/bash',
  SESSION_MANAGER:
   'local/digitalocean:@/tmp/.ICE-unix/1003,unix/digitalocean:/tmp/.ICE-unix/1003',
  COLORTERM: 'truecolor',
  SSH_AUTH_SOCK: '/run/user/1000/keyring/ssh',
  XMODIFIERS: '@im=ibus',
  DESKTOP_SESSION: 'ubuntu',
  SSH_AGENT_PID: '1150',
  PWD: '/home/sammy/first-program',
  LOGNAME: 'sammy',
  GPG_AGENT_INFO: '/run/user/1000/gnupg/S.gpg-agent:0:1',
  GJS_DEBUG_TOPICS: 'JS ERROR;JS LOG',
  WINDOWPATH: '2',
  HOME: '/home/sammy',
  USERNAME: 'sammy',
  IM_CONFIG_PHASE: '2',
  LANG: 'en_US.UTF-8',
  VTE_VERSION: '5601',
  CLUTTER_IM_MODULE: 'xim',
  GJS_DEBUG_OUTPUT: 'stderr',
  LESSCLOSE: '/usr/bin/lesspipe %s %s',
  TERM: 'xterm-256color',
  LESSOPEN: '| /usr/bin/lesspipe %s',
  USER: 'sammy',
  DISPLAY: ':0',
  SHLVL: '1',
  PATH: '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin',
  DBUS_SESSION_BUS_ADDRESS: 'unix:path=/run/user/1000/bus',
  _: '/usr/bin/node',
  OLDPWD: '/home/sammy' }
</code></pre>
<p>Ten en cuenta que muchas de las variables de entorno que ves dependen de la configuración y los ajustes de tu sistema, y tu resultado puede verse sustancialmente diferente de lo que ves aquí. En lugar de ver una larga lista de variables de entorno, es posible que necesites recuperar un valor específico.</p>
<h2>Paso 5 - Acceder a una variable de entorno específica</h2>
<p>En este paso, verás las variables de entorno y sus valores mediante el objeto global <code>process.env</code> e imprimirás sus valores en la consola.</p>
<p>El objeto <code>process.env</code> es un mapeo simple entre los nombres de las variables de entorno y sus valores almacenados como cadenas. Como todos los objetos en JavaScript, puedes acceder a una propiedad individual haciendo referencia a su nombre entre corchetes.</p>
<p>Abre el archivo <code>environment.js</code> para editarlo:</p>
<pre><code class="language-bash">nano environment.js
</code></pre>
<p>Cambia <code>console.log(process.env);</code> por:</p>
<pre><code class="language-javascript">console.log(process.env["HOME"]);
</code></pre>
<p>Guarda el archivo y ciérralo. Ahora ejecuta el programa <code>environment.js</code>:</p>
<pre><code class="language-bash">node environment.js
</code></pre>
<p>La salida ahora se ve así:</p>
<pre><code class="language-bash">/home/sammy
</code></pre>
<p>En lugar de imprimir todo el objeto, ahora solo se imprime la propiedad <code>HOME</code> de <code>process.env</code>, que almacena el valor de la variable de entorno <code>$HOME</code>.</p>
<p>Nuevamente, ten en cuenta que la salida de este código probablemente será diferente a la que ves aquí porque es específica de tu sistema. Ahora que puedes especificar la variable de entorno a recuperar, puedes mejorar tu programa preguntando al usuario la variable que desea ver.</p>
<h2>Paso 6 - Recuperación de un argumento en respuesta a la entrada del usuario</h2>
<p>A continuación, utilizarás la capacidad de leer argumentos de línea de comando y variables de entorno para crear una utilidad de línea de comando que imprima el valor de una variable de entorno en la pantalla.</p>
<p>Utiliza nano para crear un nuevo archivo <code>echo.js</code>:</p>
<pre><code class="language-bash">nano echo.js
</code></pre>
<p>Agrega el siguiente código:</p>
<pre><code class="language-javascript">const args = process.argv.slice(2);
console.log(process.env[args[0]]);
</code></pre>
<p>La primera línea de <code>echo.js</code> almacena todos los argumentos de la línea de comandos que el usuario proporcionó en una variable constante llamada <code>args</code>. La segunda línea imprime la variable de entorno almacenada en el primer elemento de <code>args</code>, es decir, el primer argumento de línea de comando que proporcionó el usuario.</p>
<p>Guarda los cambios y sal de nano, luego ejecuta el programa de la siguiente manera:</p>
<pre><code class="language-bash">node echo.js HOME
</code></pre>
<p>Ahora, la salida sería:</p>
<pre><code class="language-bash">/home/sammy
</code></pre>
<p>El argumento <code>HOME</code> se guardó en el array <code>args</code>, valor que luego se usó como clave para encontrar su valor en el entorno a través del objeto <code>process.env</code>.</p>
<p>En este punto, ahora puedes acceder al valor de cualquier variable de entorno en tu sistema. Para verificar esto, intenta ver las siguientes variables: <code>PWD</code>, <code>USER</code>, <code>PATH</code>.</p>
<p>Recuperar variables individuales es bueno, pero dejar que el usuario especifique cuántas variables quiere sería mejor.</p>
<h2>Paso 7 - Visualización de múltiples variables de entorno</h2>
<p>Actualmente, la aplicación solo puede inspeccionar una variable de entorno a la vez. Sería útil si pudiéramos aceptar múltiples argumentos de línea de comandos y obtener su valor correspondiente en el entorno. Utiliza nano para editar <code>echo.js</code>:</p>
<pre><code class="language-bash">nano echo.js
</code></pre>
<p>Edita el archivo para que tenga el siguiente código:</p>
<pre><code class="language-javascript">const args = process.argv.slice(2);

args.forEach(arg => {
  console.log(process.env[arg]);
});
</code></pre>
<p>El método <code>forEach</code> es un método estándar de JavaScript en todos los objetos array. Acepta una función de devolución de llamada que se usa mientras itera sobre cada elemento de la matriz. Utiliza <code>forEach</code> en el array de argumentos, proporcionándole una función de devolución de llamada que imprime el valor del argumento actual en el entorno.</p>
<p>Guarda los cambios y sal del archivo. Ahora vuelve a ejecutar el programa con dos argumentos:</p>
<pre><code class="language-bash">node echo.js HOME PWD
</code></pre>
<p>Verás el siguiente resultado:</p>
<pre><code class="language-bash">/home/sammy
/home/sammy/first-program
</code></pre>
<p>La función <code>forEach</code> asegura que se impriman todos los argumentos de la línea de comandos en el array <code>args</code>.</p>
<p>Ahora tienes una forma de recuperar las variables que solicita el usuario, pero aún tenemos que manejar el caso en el que el usuario ingresa datos incorrectos.</p>
<h2>Paso 8 - Manejo de entrada indefinida</h2>
<p>Para ver qué sucede si le das al programa un argumento que no es una variable de entorno válida, ejecuta lo siguiente:</p>
<pre><code class="language-bash">node echo.js HOME PWD NOT_DEFINED
</code></pre>
<p>La salida se verá similar a la siguiente:</p>
<pre><code class="language-bash">/home/sammy
/home/sammy/first-program
undefined
</code></pre>
<p>Las dos primeras líneas se imprimen como se esperaba y la última línea genera una salida <code>undefined</code>. En JavaScript, un valor <code>undefined</code> significa que a una variable o propiedad no se le ha asignado un valor. Debido a que <code>NOT_DEFINED</code> no es una variable de entorno válida, se muestra como <code>undefined</code>.</p>
<p>Sería más útil para un usuario ver un mensaje de error si su argumento de línea de comando no se encuentra en el entorno.</p>
<p>Abre <code>echo.js</code> para editarlo:</p>
<pre><code class="language-bash">nano echo.js
</code></pre>
<p>Edita <code>echo.js</code> para que tenga el siguiente código:</p>
<pre><code class="language-javascript">const args = process.argv.slice(2);

args.forEach(arg => {
  let envVar = process.env[arg];
  if (envVar === undefined) {
    console.error(`Could not find "${arg}" in environment`);
  } else {
    console.log(envVar);
  }
});
</code></pre>
<p>Aquí, has modificado la función de devolución de llamada proporcionada a <code>forEach</code> para hacer las siguientes cosas:</p>
<ol>
<li>Obtener el valor del argumento de la línea de comando en el entorno y guardarlo en una variable <code>envVar</code>.</li>
<li>Comprobar si el valor de <code>envVar</code> es <code>undefined</code>.</li>
<li>Si <code>envVar</code> es <code>undefined</code>, se imprime un mensaje útil que indica que no se pudo encontrar.</li>
<li>Si se encontró una variable de entorno, imprimimos su valor.</li>
</ol>
<blockquote>
<p><strong>Nota</strong>: La función <code>console.error</code> imprime un mensaje en la pantalla a través del stream <code>stderr</code>, mientras que <code>console.log</code> imprime en la pantalla a través del stream <code>stdout</code>. Cuando ejecutas este programa a través de la línea de comando, no notará la diferencia entre los streams <code>stdout</code> y <code>stderr</code>, pero es una buena práctica imprimir los errores a través del stream <code>stderr</code> para que puedan ser identificados y procesados más fácilmente por otros programas, que sí pueden notar la diferencia.</p>
</blockquote>
<p>Ahora ejecuta el siguiente comando una vez más:</p>
<pre><code class="language-bash">node echo.js HOME PWD NOT_DEFINED
</code></pre>
<p>Esta vez la salida será:</p>
<pre><code class="language-bash">/home/sammy
/home/sammy/first-program
Could not find "NOT_DEFINED" in environme
</code></pre>
<p>Ahora, cuando proporcionas un argumento de línea de comando que no es una variable de entorno, obtienes un mensaje de error claro que lo indica.</p>
<h2>Conclusión</h2>
<p>Tu primer programa mostró un mensaje <code>"Hello World"</code> en la pantalla, y ahora has escrito una utilidad de línea de comandos Node.js que lee los argumentos del usuario para mostrar las variables de entorno.</p>
<p>Si deseas llevar esto más allá, puedes cambiar aún más el comportamiento de este programa. Por ejemplo, es posible que desees validar los argumentos de la línea de comandos antes de imprimir. Si un argumento no está definido, puede devolver un error y el usuario solo obtendrá resultados si todos los argumentos son variables de entorno válidas.</p>
</div></div></article></div></main></div><footer class="bg-neutral-50 border-t border-neutral-200"><div class="container mx-auto px-5"><div class="py-28 flex flex-col lg:flex-row items-center"><h3 class="text-4xl lg:text-[2.5rem] font-bold tracking-tighter leading-tight text-center lg:text-left mb-10 lg:mb-0 lg:pr-4 lg:w-1/5">FabDev</h3><div class="flex flex-col lg:flex-row justify-center items-center lg:pl-4 lg:w-4/5"><a href="https://backend-verse.com" class="mx-3 bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-3 px-12 lg:px-8 duration-200 transition-colors mb-6 lg:mb-0">Backend-Verse</a><a href="https://github.com/fabiankaraben" class="mx-3 font-bold hover:underline">GitHub</a><a href="https://www.linkedin.com/in/fabiankaraben/" class="mx-3 font-bold hover:underline">LinkedIn</a><a href="https://www.youtube.com/channel/UCBu3Gofz6KehltM4jfmr-qA" class="mx-3 font-bold hover:underline">YouTube</a><a href="https://twitter.com/fab_k_dev" class="mx-3 font-bold hover:underline">Twitter</a><a href="https://www.instagram.com/fab.k.dev/" class="mx-3 font-bold hover:underline">Instagram</a></div></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Cómo escribir y ejecutar tu primer programa en Node.js","date":"2021-12-15T05:35:07.322Z","slug":"nodejs/tu-primer-programa","author":{"name":"Fabián Karaben","picture":"/assets/authors/fabian.png"},"content":"\u003cp\u003eNode.js es un entorno de ejecución de código abierto popular que puede ejecutar JavaScript fuera del navegador mediante el motor JavaScript V8, que es el mismo motor que se utiliza el navegador web Google Chrome para la ejecución de JavaScript. El \u003cem\u003eruntime\u003c/em\u003e de Node se usa comúnmente para crear herramientas de línea de comandos y servidores web.\u003c/p\u003e\n\u003cp\u003eAprender \u003cstrong\u003eNode.js\u003c/strong\u003e te permitirá escribir tu código de frontend y tu código de backend en el mismo lenguaje. El uso de JavaScript en toda tu pila de trabajo puede ayudarte a reducir el tiempo de desarrollo, además las bibliotecas se compartirán fácilmente entre el servidor backend y tus proyectos frontend.\u003c/p\u003e\n\u003cp\u003eAdemás, gracias a su soporte para ejecución asincrónica, Node.js sobresale en tareas intensivas de I/O (Entrada/Salida), que es lo que lo hace tan adecuado para la web. Las aplicaciones en tiempo real, como la transmisión de video, o las aplicaciones que envían y reciben datos continuamente, pueden ejecutarse de manera más eficiente cuando se escriben en Node.js.\u003c/p\u003e\n\u003cp\u003eEn este tutorial, crearás tu primer programa con el runtime de Node.js. Se te presentarán algunos conceptos específicos de Node y te abrirás camino para crear un programa que ayude a los usuarios a inspeccionar las variables de entorno en su sistema. Para hacer esto, aprenderás cómo enviar cadenas a la consola, recibir información del usuario y acceder a las variables de entorno.\u003c/p\u003e\n\u003ch2\u003ePrerrequisitos\u003c/h2\u003e\n\u003cp\u003ePara completar este tutorial, necesitarás:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eNode.js instalado en tu máquina de desarrollo. Este tutorial usa Node.js versión 10.16.0. Para instalar esto en macOS o Ubuntu 18.04, sigue los pasos en \u003ca href=\"https://www.digitalocean.com/community/tutorials/how-to-install-node-js-and-create-a-local-development-environment-on-macos\"\u003eCómo instalar Node.js y crear un entorno de desarrollo local en macOS\u003c/a\u003e o la sección \"Instalación mediante un PPA\" de \u003ca href=\"https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-18-04\"\u003eCómo instalar Node.js en Ubuntu 18.04\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUn conocimiento básico de JavaScript, que puedes encontrar aquí: \u003ca href=\"https://www.digitalocean.com/community/tutorial_series/how-to-code-in-javascript\"\u003eCómo codificar en JavaScript\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003ePaso 1 - Salidas en la consola\u003c/h2\u003e\n\u003cp\u003ePara escribir un programa \"¡Hola, mundo!\", abre un editor de texto de línea de comando como \u003cem\u003enano\u003c/em\u003e y crea un nuevo archivo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enano hello.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCon el editor de texto abierto, escribe el siguiente código:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econsole.log(\"Hello World\");\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl objeto de \u003ccode\u003econsole\u003c/code\u003e en Node.js es proporcionar métodos simples para escribir en \u003ccode\u003estdout\u003c/code\u003e, \u003ccode\u003estderr\u003c/code\u003e o en cualquier otro flujo de Node.js, que en la mayoría de los casos es la línea de comandos. El método \u003ccode\u003elog\u003c/code\u003e imprime el contenido especificado en la salida estándar, para que puedas verlo en tu consola.\u003c/p\u003e\n\u003cp\u003eEn el contexto de Node.js, los \u003ccode\u003estreams\u003c/code\u003e son objetos que pueden recibir datos, como la transmisión \u003ccode\u003estdout\u003c/code\u003e, u objetos que pueden generar datos, como un conector de red o un archivo. En el caso de las transmisiones (\u003ccode\u003estreams\u003c/code\u003e) \u003ccode\u003estdout\u003c/code\u003e y \u003ccode\u003estderr\u003c/code\u003e, todos los datos que se les envíen se mostrarán en la consola. Una de las mejores cosas de las transmisiones es que se redirigen fácilmente, en cuyo caso puedes redirigir la salida de tu programa a un archivo, por ejemplo.\u003c/p\u003e\n\u003cp\u003eGuarda los cambios y cierra nano presionando \u003cem\u003eCTRL+X\u003c/em\u003e, y cuando se te solicite guardar el archivo, presiona \u003cem\u003eY\u003c/em\u003e. Ahora tu programa está listo para ejecutarse.\u003c/p\u003e\n\u003ch2\u003ePaso 2 - Ejecución del programa\u003c/h2\u003e\n\u003cp\u003ePara ejecutar este programa, utiliza el comando de \u003ccode\u003enode\u003c/code\u003e de la siguiente manera:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode hello.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl programa \u003ccode\u003ehello.js\u003c/code\u003e se ejecutará y mostrará el siguiente resultado:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eHello World\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl intérprete de Node.js leyó el archivo y ejecutó \u003ccode\u003econsole.log(\"Hello World\");\u003c/code\u003e llamando al método \u003ccode\u003elog\u003c/code\u003e del objeto global \u003ccode\u003econsole\u003c/code\u003e. La cadena \u003ccode\u003e\"Hello World\"\u003c/code\u003e se pasó como argumento a la función \u003ccode\u003elog\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAunque las comillas son necesarias en el código para indicar que el texto es una cadena, no se imprimen en la pantalla.\u003c/p\u003e\n\u003cp\u003eUna vez confirmado que el programa funciona, hagámoslo más interactivo.\u003c/p\u003e\n\u003ch2\u003ePaso 3 - Recibir de la entrada del usuario a través de argumentos de línea de comandos\u003c/h2\u003e\n\u003cp\u003eCada vez que ejecutas  programa Node.js \"¡Hola, mundo!\", produces la misma salida. Para que el programa sea más dinámico, obtengamos información del usuario y mostrémosla en la pantalla.\u003c/p\u003e\n\u003cp\u003eLas herramientas de línea de comandos a menudo aceptan varios argumentos que modifican su comportamiento. Por ejemplo, ejecutar \u003ccode\u003enode\u003c/code\u003e con el argumento \u003ccode\u003e--version\u003c/code\u003e imprime la versión instalada en lugar de ejecutar el intérprete. En este paso, harás que tu código acepte la entrada del usuario a través de argumentos de línea de comandos.\u003c/p\u003e\n\u003cp\u003ePara ello, crea un nuevo archivo \u003ccode\u003earguments.js\u003c/code\u003e con nano:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enano arguments.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEscribe el siguiente código:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econsole.log(process.argv);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl objeto \u003ccode\u003eprocess\u003c/code\u003e es un objeto Node.js global que contiene funciones y datos relacionados con el proceso Node.js que se está ejecutando actualmente. La propiedad \u003ccode\u003eargv\u003c/code\u003e es una array de strings que contiene todos los argumentos pasados al programa desde la línea de comandos.\u003c/p\u003e\n\u003cp\u003eGuarda los cambios y sal de nano escribiendo \u003cem\u003eCTRL+X\u003c/em\u003e, cuando se te solicite guardar el archivo, presiona \u003cem\u003eY\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAhora, cuando ejecutes este programa, añade algunos argumentos al comando, como por ejemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode arguments.js hello world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLa salida se parecerá a la siguiente:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e[ '/usr/bin/node',\n  '/home/sammy/first-program/arguments.js',\n  'hello',\n  'world' ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl primer argumento en el array \u003ccode\u003eprocess.argv\u003c/code\u003e es siempre la ubicación del binario Node.js que está ejecutando el programa. El segundo argumento es siempre la ubicación del archivo que se está ejecutando. Los argumentos restantes son los que ingresó el usuario, en este caso: \u003ccode\u003ehello\u003c/code\u003e y \u003ccode\u003eworld\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLo que más nos interesa son los argumentos que ingresó el usuario, no los predeterminados que proporciona Node.js. Abre el archivo \u003ccode\u003earguments.js\u003c/code\u003e nuevamente para editarlo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enano arguments.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCambiar \u003ccode\u003econsole.log(process.argv);\u003c/code\u003e a lo siguiente:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econsole.log(process.argv.slice(2));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDebido a que \u003ccode\u003eargv\u003c/code\u003e es un array, puedes usar el método \u003ccode\u003eslice\u003c/code\u003e integrado de JavaScript que devuelve una selección de elementos. Cuando proporcionas a la función \u003ccode\u003eslice\u003c/code\u003e el valor \u003ccode\u003e2\u003c/code\u003e como argumento, obtienes todos los elementos de \u003ccode\u003eargv\u003c/code\u003e que vienen después de su segundo elemento; es decir, los argumentos que ingresó el usuario.\u003c/p\u003e\n\u003cp\u003eVuelve a ejecutar el programa con el comando \u003ccode\u003enode\u003c/code\u003e y los mismos argumentos que la última vez:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode arguments.js hello world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAhora, la salida se ve así:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e[ 'hello', 'world' ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAhora que ya puedes recopilar información del usuario, recopilemos también información del entorno del programa.\u003c/p\u003e\n\u003ch2\u003ePaso 4 - Acceder a las variables de entorno\u003c/h2\u003e\n\u003cp\u003eLas variables de entorno son datos de tipo \u003cem\u003eclave:valor\u003c/em\u003e almacenados fuera de un programa y proporcionados por el sistema operativo. Por lo general, los establece el sistema o el usuario y están disponibles para todos los procesos en ejecución con fines de configuración o de estado. Puedes utilizar el objeto \u003ccode\u003eprocess\u003c/code\u003e de Node para acceder a ellos.\u003c/p\u003e\n\u003cp\u003eUtiliza nano para crear un nuevo archivo \u003ccode\u003eenvironment.js\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enano environment.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgrega el siguiente código:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econsole.log(process.env);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl objeto \u003ccode\u003eenv\u003c/code\u003e almacena todas las variables de entorno que están disponibles cuando Node.js está ejecutando el programa.\u003c/p\u003e\n\u003cp\u003eGuarda y sal como antes, y ejecuta el archivo \u003ccode\u003eenvironment.js\u003c/code\u003e con el comando \u003ccode\u003enode\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode environment.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAl ejecutar el programa, deberías ver un resultado similar al siguiente:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e{ SHELL: '/bin/bash',\n  SESSION_MANAGER:\n   'local/digitalocean:@/tmp/.ICE-unix/1003,unix/digitalocean:/tmp/.ICE-unix/1003',\n  COLORTERM: 'truecolor',\n  SSH_AUTH_SOCK: '/run/user/1000/keyring/ssh',\n  XMODIFIERS: '@im=ibus',\n  DESKTOP_SESSION: 'ubuntu',\n  SSH_AGENT_PID: '1150',\n  PWD: '/home/sammy/first-program',\n  LOGNAME: 'sammy',\n  GPG_AGENT_INFO: '/run/user/1000/gnupg/S.gpg-agent:0:1',\n  GJS_DEBUG_TOPICS: 'JS ERROR;JS LOG',\n  WINDOWPATH: '2',\n  HOME: '/home/sammy',\n  USERNAME: 'sammy',\n  IM_CONFIG_PHASE: '2',\n  LANG: 'en_US.UTF-8',\n  VTE_VERSION: '5601',\n  CLUTTER_IM_MODULE: 'xim',\n  GJS_DEBUG_OUTPUT: 'stderr',\n  LESSCLOSE: '/usr/bin/lesspipe %s %s',\n  TERM: 'xterm-256color',\n  LESSOPEN: '| /usr/bin/lesspipe %s',\n  USER: 'sammy',\n  DISPLAY: ':0',\n  SHLVL: '1',\n  PATH: '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin',\n  DBUS_SESSION_BUS_ADDRESS: 'unix:path=/run/user/1000/bus',\n  _: '/usr/bin/node',\n  OLDPWD: '/home/sammy' }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTen en cuenta que muchas de las variables de entorno que ves dependen de la configuración y los ajustes de tu sistema, y tu resultado puede verse sustancialmente diferente de lo que ves aquí. En lugar de ver una larga lista de variables de entorno, es posible que necesites recuperar un valor específico.\u003c/p\u003e\n\u003ch2\u003ePaso 5 - Acceder a una variable de entorno específica\u003c/h2\u003e\n\u003cp\u003eEn este paso, verás las variables de entorno y sus valores mediante el objeto global \u003ccode\u003eprocess.env\u003c/code\u003e e imprimirás sus valores en la consola.\u003c/p\u003e\n\u003cp\u003eEl objeto \u003ccode\u003eprocess.env\u003c/code\u003e es un mapeo simple entre los nombres de las variables de entorno y sus valores almacenados como cadenas. Como todos los objetos en JavaScript, puedes acceder a una propiedad individual haciendo referencia a su nombre entre corchetes.\u003c/p\u003e\n\u003cp\u003eAbre el archivo \u003ccode\u003eenvironment.js\u003c/code\u003e para editarlo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enano environment.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCambia \u003ccode\u003econsole.log(process.env);\u003c/code\u003e por:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econsole.log(process.env[\"HOME\"]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGuarda el archivo y ciérralo. Ahora ejecuta el programa \u003ccode\u003eenvironment.js\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode environment.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLa salida ahora se ve así:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e/home/sammy\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEn lugar de imprimir todo el objeto, ahora solo se imprime la propiedad \u003ccode\u003eHOME\u003c/code\u003e de \u003ccode\u003eprocess.env\u003c/code\u003e, que almacena el valor de la variable de entorno \u003ccode\u003e$HOME\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNuevamente, ten en cuenta que la salida de este código probablemente será diferente a la que ves aquí porque es específica de tu sistema. Ahora que puedes especificar la variable de entorno a recuperar, puedes mejorar tu programa preguntando al usuario la variable que desea ver.\u003c/p\u003e\n\u003ch2\u003ePaso 6 - Recuperación de un argumento en respuesta a la entrada del usuario\u003c/h2\u003e\n\u003cp\u003eA continuación, utilizarás la capacidad de leer argumentos de línea de comando y variables de entorno para crear una utilidad de línea de comando que imprima el valor de una variable de entorno en la pantalla.\u003c/p\u003e\n\u003cp\u003eUtiliza nano para crear un nuevo archivo \u003ccode\u003eecho.js\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enano echo.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgrega el siguiente código:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst args = process.argv.slice(2);\nconsole.log(process.env[args[0]]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLa primera línea de \u003ccode\u003eecho.js\u003c/code\u003e almacena todos los argumentos de la línea de comandos que el usuario proporcionó en una variable constante llamada \u003ccode\u003eargs\u003c/code\u003e. La segunda línea imprime la variable de entorno almacenada en el primer elemento de \u003ccode\u003eargs\u003c/code\u003e, es decir, el primer argumento de línea de comando que proporcionó el usuario.\u003c/p\u003e\n\u003cp\u003eGuarda los cambios y sal de nano, luego ejecuta el programa de la siguiente manera:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode echo.js HOME\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAhora, la salida sería:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e/home/sammy\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl argumento \u003ccode\u003eHOME\u003c/code\u003e se guardó en el array \u003ccode\u003eargs\u003c/code\u003e, valor que luego se usó como clave para encontrar su valor en el entorno a través del objeto \u003ccode\u003eprocess.env\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eEn este punto, ahora puedes acceder al valor de cualquier variable de entorno en tu sistema. Para verificar esto, intenta ver las siguientes variables: \u003ccode\u003ePWD\u003c/code\u003e, \u003ccode\u003eUSER\u003c/code\u003e, \u003ccode\u003ePATH\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eRecuperar variables individuales es bueno, pero dejar que el usuario especifique cuántas variables quiere sería mejor.\u003c/p\u003e\n\u003ch2\u003ePaso 7 - Visualización de múltiples variables de entorno\u003c/h2\u003e\n\u003cp\u003eActualmente, la aplicación solo puede inspeccionar una variable de entorno a la vez. Sería útil si pudiéramos aceptar múltiples argumentos de línea de comandos y obtener su valor correspondiente en el entorno. Utiliza nano para editar \u003ccode\u003eecho.js\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enano echo.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEdita el archivo para que tenga el siguiente código:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst args = process.argv.slice(2);\n\nargs.forEach(arg =\u003e {\n  console.log(process.env[arg]);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEl método \u003ccode\u003eforEach\u003c/code\u003e es un método estándar de JavaScript en todos los objetos array. Acepta una función de devolución de llamada que se usa mientras itera sobre cada elemento de la matriz. Utiliza \u003ccode\u003eforEach\u003c/code\u003e en el array de argumentos, proporcionándole una función de devolución de llamada que imprime el valor del argumento actual en el entorno.\u003c/p\u003e\n\u003cp\u003eGuarda los cambios y sal del archivo. Ahora vuelve a ejecutar el programa con dos argumentos:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode echo.js HOME PWD\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVerás el siguiente resultado:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e/home/sammy\n/home/sammy/first-program\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLa función \u003ccode\u003eforEach\u003c/code\u003e asegura que se impriman todos los argumentos de la línea de comandos en el array \u003ccode\u003eargs\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAhora tienes una forma de recuperar las variables que solicita el usuario, pero aún tenemos que manejar el caso en el que el usuario ingresa datos incorrectos.\u003c/p\u003e\n\u003ch2\u003ePaso 8 - Manejo de entrada indefinida\u003c/h2\u003e\n\u003cp\u003ePara ver qué sucede si le das al programa un argumento que no es una variable de entorno válida, ejecuta lo siguiente:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode echo.js HOME PWD NOT_DEFINED\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLa salida se verá similar a la siguiente:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e/home/sammy\n/home/sammy/first-program\nundefined\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLas dos primeras líneas se imprimen como se esperaba y la última línea genera una salida \u003ccode\u003eundefined\u003c/code\u003e. En JavaScript, un valor \u003ccode\u003eundefined\u003c/code\u003e significa que a una variable o propiedad no se le ha asignado un valor. Debido a que \u003ccode\u003eNOT_DEFINED\u003c/code\u003e no es una variable de entorno válida, se muestra como \u003ccode\u003eundefined\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSería más útil para un usuario ver un mensaje de error si su argumento de línea de comando no se encuentra en el entorno.\u003c/p\u003e\n\u003cp\u003eAbre \u003ccode\u003eecho.js\u003c/code\u003e para editarlo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enano echo.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEdita \u003ccode\u003eecho.js\u003c/code\u003e para que tenga el siguiente código:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst args = process.argv.slice(2);\n\nargs.forEach(arg =\u003e {\n  let envVar = process.env[arg];\n  if (envVar === undefined) {\n    console.error(`Could not find \"${arg}\" in environment`);\n  } else {\n    console.log(envVar);\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAquí, has modificado la función de devolución de llamada proporcionada a \u003ccode\u003eforEach\u003c/code\u003e para hacer las siguientes cosas:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eObtener el valor del argumento de la línea de comando en el entorno y guardarlo en una variable \u003ccode\u003eenvVar\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eComprobar si el valor de \u003ccode\u003eenvVar\u003c/code\u003e es \u003ccode\u003eundefined\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eSi \u003ccode\u003eenvVar\u003c/code\u003e es \u003ccode\u003eundefined\u003c/code\u003e, se imprime un mensaje útil que indica que no se pudo encontrar.\u003c/li\u003e\n\u003cli\u003eSi se encontró una variable de entorno, imprimimos su valor.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eNota\u003c/strong\u003e: La función \u003ccode\u003econsole.error\u003c/code\u003e imprime un mensaje en la pantalla a través del stream \u003ccode\u003estderr\u003c/code\u003e, mientras que \u003ccode\u003econsole.log\u003c/code\u003e imprime en la pantalla a través del stream \u003ccode\u003estdout\u003c/code\u003e. Cuando ejecutas este programa a través de la línea de comando, no notará la diferencia entre los streams \u003ccode\u003estdout\u003c/code\u003e y \u003ccode\u003estderr\u003c/code\u003e, pero es una buena práctica imprimir los errores a través del stream \u003ccode\u003estderr\u003c/code\u003e para que puedan ser identificados y procesados más fácilmente por otros programas, que sí pueden notar la diferencia.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAhora ejecuta el siguiente comando una vez más:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode echo.js HOME PWD NOT_DEFINED\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEsta vez la salida será:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e/home/sammy\n/home/sammy/first-program\nCould not find \"NOT_DEFINED\" in environme\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAhora, cuando proporcionas un argumento de línea de comando que no es una variable de entorno, obtienes un mensaje de error claro que lo indica.\u003c/p\u003e\n\u003ch2\u003eConclusión\u003c/h2\u003e\n\u003cp\u003eTu primer programa mostró un mensaje \u003ccode\u003e\"Hello World\"\u003c/code\u003e en la pantalla, y ahora has escrito una utilidad de línea de comandos Node.js que lee los argumentos del usuario para mostrar las variables de entorno.\u003c/p\u003e\n\u003cp\u003eSi deseas llevar esto más allá, puedes cambiar aún más el comportamiento de este programa. Por ejemplo, es posible que desees validar los argumentos de la línea de comandos antes de imprimir. Si un argumento no está definido, puede devolver un error y el usuario solo obtendrá resultados si todos los argumentos son variables de entorno válidas.\u003c/p\u003e\n","ogImage":{"url":"/assets/nodejs/tu-primer-programa.png"},"coverImage":"/assets/nodejs/tu-primer-programa.png"}},"__N_SSG":true},"page":"/[...slug]","query":{"slug":["nodejs","tu-primer-programa"]},"buildId":"Wx3sdiSJXS0VkloYAT539","isFallback":false,"gsp":true,"scriptLoader":[]}</script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-215112498-1"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'UA-215112498-1');
              </script></body></html>