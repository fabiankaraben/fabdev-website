{"pageProps":{"post":{"title":"Cómo escribir y ejecutar tu primer programa en Node.js","date":"2021-12-15T05:35:07.322Z","slug":"nodejs/tu-primer-programa","author":{"name":"Fabián Karaben","picture":"/assets/authors/fabian.png"},"content":"<p>Node.js es un entorno de ejecución de código abierto popular que puede ejecutar JavaScript fuera del navegador mediante el motor JavaScript V8, que es el mismo motor que se utiliza el navegador web Google Chrome para la ejecución de JavaScript. El <em>runtime</em> de Node se usa comúnmente para crear herramientas de línea de comandos y servidores web.</p>\n<p>Aprender <strong>Node.js</strong> te permitirá escribir tu código de frontend y tu código de backend en el mismo lenguaje. El uso de JavaScript en toda tu pila de trabajo puede ayudarte a reducir el tiempo de desarrollo, además las bibliotecas se compartirán fácilmente entre el servidor backend y tus proyectos frontend.</p>\n<p>Además, gracias a su soporte para ejecución asincrónica, Node.js sobresale en tareas intensivas de I/O (Entrada/Salida), que es lo que lo hace tan adecuado para la web. Las aplicaciones en tiempo real, como la transmisión de video, o las aplicaciones que envían y reciben datos continuamente, pueden ejecutarse de manera más eficiente cuando se escriben en Node.js.</p>\n<p>En este tutorial, crearás tu primer programa con el runtime de Node.js. Se te presentarán algunos conceptos específicos de Node y te abrirás camino para crear un programa que ayude a los usuarios a inspeccionar las variables de entorno en su sistema. Para hacer esto, aprenderás cómo enviar cadenas a la consola, recibir información del usuario y acceder a las variables de entorno.</p>\n<h2>Prerrequisitos</h2>\n<p>Para completar este tutorial, necesitarás:</p>\n<ul>\n<li>\n<p>Node.js instalado en tu máquina de desarrollo. Este tutorial usa Node.js versión 10.16.0. Para instalar esto en macOS o Ubuntu 18.04, sigue los pasos en <a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-node-js-and-create-a-local-development-environment-on-macos\">Cómo instalar Node.js y crear un entorno de desarrollo local en macOS</a> o la sección \"Instalación mediante un PPA\" de <a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-18-04\">Cómo instalar Node.js en Ubuntu 18.04</a>.</p>\n</li>\n<li>\n<p>Un conocimiento básico de JavaScript, que puedes encontrar aquí: <a href=\"https://www.digitalocean.com/community/tutorial_series/how-to-code-in-javascript\">Cómo codificar en JavaScript</a>.</p>\n</li>\n</ul>\n<h2>Paso 1 - Salidas en la consola</h2>\n<p>Para escribir un programa \"¡Hola, mundo!\", abre un editor de texto de línea de comando como <em>nano</em> y crea un nuevo archivo:</p>\n<pre><code class=\"language-bash\">nano hello.js\n</code></pre>\n<p>Con el editor de texto abierto, escribe el siguiente código:</p>\n<pre><code class=\"language-javascript\">console.log(\"Hello World\");\n</code></pre>\n<p>El objeto de <code>console</code> en Node.js es proporcionar métodos simples para escribir en <code>stdout</code>, <code>stderr</code> o en cualquier otro flujo de Node.js, que en la mayoría de los casos es la línea de comandos. El método <code>log</code> imprime el contenido especificado en la salida estándar, para que puedas verlo en tu consola.</p>\n<p>En el contexto de Node.js, los <code>streams</code> son objetos que pueden recibir datos, como la transmisión <code>stdout</code>, u objetos que pueden generar datos, como un conector de red o un archivo. En el caso de las transmisiones (<code>streams</code>) <code>stdout</code> y <code>stderr</code>, todos los datos que se les envíen se mostrarán en la consola. Una de las mejores cosas de las transmisiones es que se redirigen fácilmente, en cuyo caso puedes redirigir la salida de tu programa a un archivo, por ejemplo.</p>\n<p>Guarda los cambios y cierra nano presionando <em>CTRL+X</em>, y cuando se te solicite guardar el archivo, presiona <em>Y</em>. Ahora tu programa está listo para ejecutarse.</p>\n<h2>Paso 2 - Ejecución del programa</h2>\n<p>Para ejecutar este programa, utiliza el comando de <code>node</code> de la siguiente manera:</p>\n<pre><code class=\"language-bash\">node hello.js\n</code></pre>\n<p>El programa <code>hello.js</code> se ejecutará y mostrará el siguiente resultado:</p>\n<pre><code class=\"language-bash\">Hello World\n</code></pre>\n<p>El intérprete de Node.js leyó el archivo y ejecutó <code>console.log(\"Hello World\");</code> llamando al método <code>log</code> del objeto global <code>console</code>. La cadena <code>\"Hello World\"</code> se pasó como argumento a la función <code>log</code>.</p>\n<p>Aunque las comillas son necesarias en el código para indicar que el texto es una cadena, no se imprimen en la pantalla.</p>\n<p>Una vez confirmado que el programa funciona, hagámoslo más interactivo.</p>\n<h2>Paso 3 - Recibir de la entrada del usuario a través de argumentos de línea de comandos</h2>\n<p>Cada vez que ejecutas  programa Node.js \"¡Hola, mundo!\", produces la misma salida. Para que el programa sea más dinámico, obtengamos información del usuario y mostrémosla en la pantalla.</p>\n<p>Las herramientas de línea de comandos a menudo aceptan varios argumentos que modifican su comportamiento. Por ejemplo, ejecutar <code>node</code> con el argumento <code>--version</code> imprime la versión instalada en lugar de ejecutar el intérprete. En este paso, harás que tu código acepte la entrada del usuario a través de argumentos de línea de comandos.</p>\n<p>Para ello, crea un nuevo archivo <code>arguments.js</code> con nano:</p>\n<pre><code class=\"language-bash\">nano arguments.js\n</code></pre>\n<p>Escribe el siguiente código:</p>\n<pre><code class=\"language-javascript\">console.log(process.argv);\n</code></pre>\n<p>El objeto <code>process</code> es un objeto Node.js global que contiene funciones y datos relacionados con el proceso Node.js que se está ejecutando actualmente. La propiedad <code>argv</code> es una array de strings que contiene todos los argumentos pasados al programa desde la línea de comandos.</p>\n<p>Guarda los cambios y sal de nano escribiendo <em>CTRL+X</em>, cuando se te solicite guardar el archivo, presiona <em>Y</em>.</p>\n<p>Ahora, cuando ejecutes este programa, añade algunos argumentos al comando, como por ejemplo:</p>\n<pre><code class=\"language-bash\">node arguments.js hello world\n</code></pre>\n<p>La salida se parecerá a la siguiente:</p>\n<pre><code class=\"language-bash\">[ '/usr/bin/node',\n  '/home/sammy/first-program/arguments.js',\n  'hello',\n  'world' ]\n</code></pre>\n<p>El primer argumento en el array <code>process.argv</code> es siempre la ubicación del binario Node.js que está ejecutando el programa. El segundo argumento es siempre la ubicación del archivo que se está ejecutando. Los argumentos restantes son los que ingresó el usuario, en este caso: <code>hello</code> y <code>world</code>.</p>\n<p>Lo que más nos interesa son los argumentos que ingresó el usuario, no los predeterminados que proporciona Node.js. Abre el archivo <code>arguments.js</code> nuevamente para editarlo:</p>\n<pre><code class=\"language-bash\">nano arguments.js\n</code></pre>\n<p>Cambiar <code>console.log(process.argv);</code> a lo siguiente:</p>\n<pre><code class=\"language-javascript\">console.log(process.argv.slice(2));\n</code></pre>\n<p>Debido a que <code>argv</code> es un array, puedes usar el método <code>slice</code> integrado de JavaScript que devuelve una selección de elementos. Cuando proporcionas a la función <code>slice</code> el valor <code>2</code> como argumento, obtienes todos los elementos de <code>argv</code> que vienen después de su segundo elemento; es decir, los argumentos que ingresó el usuario.</p>\n<p>Vuelve a ejecutar el programa con el comando <code>node</code> y los mismos argumentos que la última vez:</p>\n<pre><code class=\"language-bash\">node arguments.js hello world\n</code></pre>\n<p>Ahora, la salida se ve así:</p>\n<pre><code class=\"language-bash\">[ 'hello', 'world' ]\n</code></pre>\n<p>Ahora que ya puedes recopilar información del usuario, recopilemos también información del entorno del programa.</p>\n<h2>Paso 4 - Acceder a las variables de entorno</h2>\n<p>Las variables de entorno son datos de tipo <em>clave:valor</em> almacenados fuera de un programa y proporcionados por el sistema operativo. Por lo general, los establece el sistema o el usuario y están disponibles para todos los procesos en ejecución con fines de configuración o de estado. Puedes utilizar el objeto <code>process</code> de Node para acceder a ellos.</p>\n<p>Utiliza nano para crear un nuevo archivo <code>environment.js</code>:</p>\n<pre><code class=\"language-bash\">nano environment.js\n</code></pre>\n<p>Agrega el siguiente código:</p>\n<pre><code class=\"language-javascript\">console.log(process.env);\n</code></pre>\n<p>El objeto <code>env</code> almacena todas las variables de entorno que están disponibles cuando Node.js está ejecutando el programa.</p>\n<p>Guarda y sal como antes, y ejecuta el archivo <code>environment.js</code> con el comando <code>node</code>.</p>\n<pre><code class=\"language-bash\">node environment.js\n</code></pre>\n<p>Al ejecutar el programa, deberías ver un resultado similar al siguiente:</p>\n<pre><code class=\"language-bash\">{ SHELL: '/bin/bash',\n  SESSION_MANAGER:\n   'local/digitalocean:@/tmp/.ICE-unix/1003,unix/digitalocean:/tmp/.ICE-unix/1003',\n  COLORTERM: 'truecolor',\n  SSH_AUTH_SOCK: '/run/user/1000/keyring/ssh',\n  XMODIFIERS: '@im=ibus',\n  DESKTOP_SESSION: 'ubuntu',\n  SSH_AGENT_PID: '1150',\n  PWD: '/home/sammy/first-program',\n  LOGNAME: 'sammy',\n  GPG_AGENT_INFO: '/run/user/1000/gnupg/S.gpg-agent:0:1',\n  GJS_DEBUG_TOPICS: 'JS ERROR;JS LOG',\n  WINDOWPATH: '2',\n  HOME: '/home/sammy',\n  USERNAME: 'sammy',\n  IM_CONFIG_PHASE: '2',\n  LANG: 'en_US.UTF-8',\n  VTE_VERSION: '5601',\n  CLUTTER_IM_MODULE: 'xim',\n  GJS_DEBUG_OUTPUT: 'stderr',\n  LESSCLOSE: '/usr/bin/lesspipe %s %s',\n  TERM: 'xterm-256color',\n  LESSOPEN: '| /usr/bin/lesspipe %s',\n  USER: 'sammy',\n  DISPLAY: ':0',\n  SHLVL: '1',\n  PATH: '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin',\n  DBUS_SESSION_BUS_ADDRESS: 'unix:path=/run/user/1000/bus',\n  _: '/usr/bin/node',\n  OLDPWD: '/home/sammy' }\n</code></pre>\n<p>Ten en cuenta que muchas de las variables de entorno que ves dependen de la configuración y los ajustes de tu sistema, y tu resultado puede verse sustancialmente diferente de lo que ves aquí. En lugar de ver una larga lista de variables de entorno, es posible que necesites recuperar un valor específico.</p>\n<h2>Paso 5 - Acceder a una variable de entorno específica</h2>\n<p>En este paso, verás las variables de entorno y sus valores mediante el objeto global <code>process.env</code> e imprimirás sus valores en la consola.</p>\n<p>El objeto <code>process.env</code> es un mapeo simple entre los nombres de las variables de entorno y sus valores almacenados como cadenas. Como todos los objetos en JavaScript, puedes acceder a una propiedad individual haciendo referencia a su nombre entre corchetes.</p>\n<p>Abre el archivo <code>environment.js</code> para editarlo:</p>\n<pre><code class=\"language-bash\">nano environment.js\n</code></pre>\n<p>Cambia <code>console.log(process.env);</code> por:</p>\n<pre><code class=\"language-javascript\">console.log(process.env[\"HOME\"]);\n</code></pre>\n<p>Guarda el archivo y ciérralo. Ahora ejecuta el programa <code>environment.js</code>:</p>\n<pre><code class=\"language-bash\">node environment.js\n</code></pre>\n<p>La salida ahora se ve así:</p>\n<pre><code class=\"language-bash\">/home/sammy\n</code></pre>\n<p>En lugar de imprimir todo el objeto, ahora solo se imprime la propiedad <code>HOME</code> de <code>process.env</code>, que almacena el valor de la variable de entorno <code>$HOME</code>.</p>\n<p>Nuevamente, ten en cuenta que la salida de este código probablemente será diferente a la que ves aquí porque es específica de tu sistema. Ahora que puedes especificar la variable de entorno a recuperar, puedes mejorar tu programa preguntando al usuario la variable que desea ver.</p>\n<h2>Paso 6 - Recuperación de un argumento en respuesta a la entrada del usuario</h2>\n<p>A continuación, utilizarás la capacidad de leer argumentos de línea de comando y variables de entorno para crear una utilidad de línea de comando que imprima el valor de una variable de entorno en la pantalla.</p>\n<p>Utiliza nano para crear un nuevo archivo <code>echo.js</code>:</p>\n<pre><code class=\"language-bash\">nano echo.js\n</code></pre>\n<p>Agrega el siguiente código:</p>\n<pre><code class=\"language-javascript\">const args = process.argv.slice(2);\nconsole.log(process.env[args[0]]);\n</code></pre>\n<p>La primera línea de <code>echo.js</code> almacena todos los argumentos de la línea de comandos que el usuario proporcionó en una variable constante llamada <code>args</code>. La segunda línea imprime la variable de entorno almacenada en el primer elemento de <code>args</code>, es decir, el primer argumento de línea de comando que proporcionó el usuario.</p>\n<p>Guarda los cambios y sal de nano, luego ejecuta el programa de la siguiente manera:</p>\n<pre><code class=\"language-bash\">node echo.js HOME\n</code></pre>\n<p>Ahora, la salida sería:</p>\n<pre><code class=\"language-bash\">/home/sammy\n</code></pre>\n<p>El argumento <code>HOME</code> se guardó en el array <code>args</code>, valor que luego se usó como clave para encontrar su valor en el entorno a través del objeto <code>process.env</code>.</p>\n<p>En este punto, ahora puedes acceder al valor de cualquier variable de entorno en tu sistema. Para verificar esto, intenta ver las siguientes variables: <code>PWD</code>, <code>USER</code>, <code>PATH</code>.</p>\n<p>Recuperar variables individuales es bueno, pero dejar que el usuario especifique cuántas variables quiere sería mejor.</p>\n<h2>Paso 7 - Visualización de múltiples variables de entorno</h2>\n<p>Actualmente, la aplicación solo puede inspeccionar una variable de entorno a la vez. Sería útil si pudiéramos aceptar múltiples argumentos de línea de comandos y obtener su valor correspondiente en el entorno. Utiliza nano para editar <code>echo.js</code>:</p>\n<pre><code class=\"language-bash\">nano echo.js\n</code></pre>\n<p>Edita el archivo para que tenga el siguiente código:</p>\n<pre><code class=\"language-javascript\">const args = process.argv.slice(2);\n\nargs.forEach(arg => {\n  console.log(process.env[arg]);\n});\n</code></pre>\n<p>El método <code>forEach</code> es un método estándar de JavaScript en todos los objetos array. Acepta una función de devolución de llamada que se usa mientras itera sobre cada elemento de la matriz. Utiliza <code>forEach</code> en el array de argumentos, proporcionándole una función de devolución de llamada que imprime el valor del argumento actual en el entorno.</p>\n<p>Guarda los cambios y sal del archivo. Ahora vuelve a ejecutar el programa con dos argumentos:</p>\n<pre><code class=\"language-bash\">node echo.js HOME PWD\n</code></pre>\n<p>Verás el siguiente resultado:</p>\n<pre><code class=\"language-bash\">/home/sammy\n/home/sammy/first-program\n</code></pre>\n<p>La función <code>forEach</code> asegura que se impriman todos los argumentos de la línea de comandos en el array <code>args</code>.</p>\n<p>Ahora tienes una forma de recuperar las variables que solicita el usuario, pero aún tenemos que manejar el caso en el que el usuario ingresa datos incorrectos.</p>\n<h2>Paso 8 - Manejo de entrada indefinida</h2>\n<p>Para ver qué sucede si le das al programa un argumento que no es una variable de entorno válida, ejecuta lo siguiente:</p>\n<pre><code class=\"language-bash\">node echo.js HOME PWD NOT_DEFINED\n</code></pre>\n<p>La salida se verá similar a la siguiente:</p>\n<pre><code class=\"language-bash\">/home/sammy\n/home/sammy/first-program\nundefined\n</code></pre>\n<p>Las dos primeras líneas se imprimen como se esperaba y la última línea genera una salida <code>undefined</code>. En JavaScript, un valor <code>undefined</code> significa que a una variable o propiedad no se le ha asignado un valor. Debido a que <code>NOT_DEFINED</code> no es una variable de entorno válida, se muestra como <code>undefined</code>.</p>\n<p>Sería más útil para un usuario ver un mensaje de error si su argumento de línea de comando no se encuentra en el entorno.</p>\n<p>Abre <code>echo.js</code> para editarlo:</p>\n<pre><code class=\"language-bash\">nano echo.js\n</code></pre>\n<p>Edita <code>echo.js</code> para que tenga el siguiente código:</p>\n<pre><code class=\"language-javascript\">const args = process.argv.slice(2);\n\nargs.forEach(arg => {\n  let envVar = process.env[arg];\n  if (envVar === undefined) {\n    console.error(`Could not find \"${arg}\" in environment`);\n  } else {\n    console.log(envVar);\n  }\n});\n</code></pre>\n<p>Aquí, has modificado la función de devolución de llamada proporcionada a <code>forEach</code> para hacer las siguientes cosas:</p>\n<ol>\n<li>Obtener el valor del argumento de la línea de comando en el entorno y guardarlo en una variable <code>envVar</code>.</li>\n<li>Comprobar si el valor de <code>envVar</code> es <code>undefined</code>.</li>\n<li>Si <code>envVar</code> es <code>undefined</code>, se imprime un mensaje útil que indica que no se pudo encontrar.</li>\n<li>Si se encontró una variable de entorno, imprimimos su valor.</li>\n</ol>\n<blockquote>\n<p><strong>Nota</strong>: La función <code>console.error</code> imprime un mensaje en la pantalla a través del stream <code>stderr</code>, mientras que <code>console.log</code> imprime en la pantalla a través del stream <code>stdout</code>. Cuando ejecutas este programa a través de la línea de comando, no notará la diferencia entre los streams <code>stdout</code> y <code>stderr</code>, pero es una buena práctica imprimir los errores a través del stream <code>stderr</code> para que puedan ser identificados y procesados más fácilmente por otros programas, que sí pueden notar la diferencia.</p>\n</blockquote>\n<p>Ahora ejecuta el siguiente comando una vez más:</p>\n<pre><code class=\"language-bash\">node echo.js HOME PWD NOT_DEFINED\n</code></pre>\n<p>Esta vez la salida será:</p>\n<pre><code class=\"language-bash\">/home/sammy\n/home/sammy/first-program\nCould not find \"NOT_DEFINED\" in environme\n</code></pre>\n<p>Ahora, cuando proporcionas un argumento de línea de comando que no es una variable de entorno, obtienes un mensaje de error claro que lo indica.</p>\n<h2>Conclusión</h2>\n<p>Tu primer programa mostró un mensaje <code>\"Hello World\"</code> en la pantalla, y ahora has escrito una utilidad de línea de comandos Node.js que lee los argumentos del usuario para mostrar las variables de entorno.</p>\n<p>Si deseas llevar esto más allá, puedes cambiar aún más el comportamiento de este programa. Por ejemplo, es posible que desees validar los argumentos de la línea de comandos antes de imprimir. Si un argumento no está definido, puede devolver un error y el usuario solo obtendrá resultados si todos los argumentos son variables de entorno válidas.</p>\n","ogImage":{"url":"/assets/nodejs/tu-primer-programa.png"},"coverImage":"/assets/nodejs/tu-primer-programa.png"}},"__N_SSG":true}